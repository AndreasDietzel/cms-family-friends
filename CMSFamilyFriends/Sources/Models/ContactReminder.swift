import Foundation
import SwiftData

/// Erinnerung für einen Kontakt (synced mit Reminders.app)
@Model
final class ContactReminder {
    var id: UUID
    
    /// Zugehöriger Kontakt
    @Relationship
    var contact: TrackedContact?
    
    /// Titel der Erinnerung
    var title: String
    
    /// Beschreibung
    var note: String?
    
    /// Fälligkeitsdatum
    var dueDate: Date?
    
    /// Priorität (1 = hoch, 2 = mittel, 3 = niedrig)
    var priority: Int
    
    /// Typ der Erinnerung
    var typeRawValue: String
    var type: ReminderType {
        get { ReminderType(rawValue: typeRawValue) ?? .contactPause }
        set { typeRawValue = newValue.rawValue }
    }
    
    /// Status
    var isCompleted: Bool
    var completedAt: Date?
    
    /// Snoozed bis
    var snoozedUntil: Date?
    
    /// Apple Reminders ID (für Sync)
    var appleReminderIdentifier: String?
    
    /// Erstellt am
    var createdAt: Date
    
    /// Wurde automatisch erstellt?
    var isAutoGenerated: Bool
    
    /// Ist die Erinnerung aktuell gesnoozed?
    var isSnoozed: Bool {
        guard let snoozedUntil = snoozedUntil else { return false }
        return snoozedUntil > Date()
    }
    
    /// Ist die Erinnerung überfällig?
    var isOverdue: Bool {
        guard let dueDate = dueDate, !isCompleted else { return false }
        return dueDate < Date()
    }
    
    init(
        contact: TrackedContact? = nil,
        title: String,
        note: String? = nil,
        dueDate: Date? = nil,
        priority: Int = 2,
        type: ReminderType = .contactPause,
        isAutoGenerated: Bool = true
    ) {
        self.id = UUID()
        self.contact = contact
        self.title = title
        self.note = note
        self.dueDate = dueDate
        self.priority = priority
        self.typeRawValue = type.rawValue
        self.isCompleted = false
        self.createdAt = Date()
        self.isAutoGenerated = isAutoGenerated
    }
    
    /// Erinnerung snoozen
    func snooze(days: Int) {
        snoozedUntil = Calendar.current.date(byAdding: .day, value: days, to: Date())
    }
    
    /// Als erledigt markieren
    func complete() {
        isCompleted = true
        completedAt = Date()
    }
}

/// Typ der Erinnerung
enum ReminderType: String, CaseIterable, Codable {
    case contactPause = "contact_pause"   // Kontaktpause-Warnung
    case birthday = "birthday"             // Geburtstag
    case followUp = "follow_up"           // Nachfassen
    case custom = "custom"                 // Benutzerdefiniert
    
    var displayName: String {
        switch self {
        case .contactPause: return "Kontaktpause"
        case .birthday: return "Geburtstag"
        case .followUp: return "Nachfassen"
        case .custom: return "Benutzerdefiniert"
        }
    }
    
    var icon: String {
        switch self {
        case .contactPause: return "exclamationmark.triangle.fill"
        case .birthday: return "gift.fill"
        case .followUp: return "arrow.uturn.left.circle.fill"
        case .custom: return "bell.fill"
        }
    }
}
